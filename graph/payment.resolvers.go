package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"log"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
	"gorm.io/gorm"
)

// CreateRazorpayOrder is the resolver for the createRazorpayOrder field.
func (r *mutationResolver) CreateRazorpayOrder(ctx context.Context, orderID string) (*model.RazorpayOrder, error) {
	log.Printf("CreateRazorpayOrder called with orderID: %s", orderID)

	// Check if services are initialized
	if r.OrderRepository == nil {
		log.Printf("CRITICAL: OrderRepository is nil")
		return nil, fmt.Errorf("order repository not initialized")
	}
	if r.PaymentService == nil {
		log.Printf("CRITICAL: PaymentService is nil")
		return nil, fmt.Errorf("payment service not initialized")
	}

	// Convert orderID from string to uint
	var id uint
	_, err := fmt.Sscanf(orderID, "%d", &id)
	if err != nil {
		log.Printf("Error parsing orderID: %v", err)
		return nil, fmt.Errorf("invalid order ID: %v", err)
	}
	log.Printf("Parsed orderID: %d", id)

	// Get the order from the database
	order, err := r.OrderRepository.GetOrderByID(id)
	if err != nil {
		log.Printf("Order not found: %v", err)
		return nil, fmt.Errorf("order not found: %v", err)
	}
	log.Printf("Found order with amount: %.2f", order.TotalAmount)

	// Create Razorpay order
	receipt := fmt.Sprintf("order_%d", order.ID)
	log.Printf("Calling Razorpay API with amount: %.2f, currency: INR, receipt: %s", order.TotalAmount, receipt)

	razorpayOrderData, err := r.PaymentService.CreateOrder(order.TotalAmount, "INR", receipt)
	if err != nil {
		log.Printf("Error creating Razorpay order: %v", err)
		return nil, fmt.Errorf("failed to create Razorpay order: %v (make sure RAZORPAY_KEY_ID and RAZORPAY_KEY_SECRET are set)", err)
	}

	log.Printf("Razorpay order created: %+v", razorpayOrderData)

	// Extract data from response with type checking
	razorpayOrderID, ok := razorpayOrderData["id"].(string)
	if !ok {
		log.Printf("Error: invalid Razorpay order ID format")
		return nil, fmt.Errorf("invalid response from Razorpay API")
	}

	// Handle amount - could be int or float64
	var amountPaise int
	switch v := razorpayOrderData["amount"].(type) {
	case int:
		amountPaise = v
	case float64:
		amountPaise = int(v)
	default:
		log.Printf("Error: invalid amount format from Razorpay")
		return nil, fmt.Errorf("invalid amount format in Razorpay response")
	}

	currency, ok := razorpayOrderData["currency"].(string)
	if !ok {
		currency = "INR" // default
	}

	// Convert amount from paise to rupees
	amountRupees := float64(amountPaise) / 100

	razorpayOrder := &model.RazorpayOrder{
		ID:       razorpayOrderID,
		Amount:   amountRupees,
		Currency: currency,
		Receipt:  &receipt,
	}

	log.Printf("Returning Razorpay order: %+v", razorpayOrder)
	return razorpayOrder, nil
}

// VerifyPayment is the resolver for the verifyPayment field.
func (r *mutationResolver) VerifyPayment(ctx context.Context, input model.VerifyPaymentInput) (*models.Payment, error) {
	log.Printf("VerifyPayment called with input: %+v", input)

	// Convert orderID from string to uint
	var orderID uint
	_, err := fmt.Sscanf(input.OrderID, "%d", &orderID)
	if err != nil {
		log.Printf("Error parsing orderID: %v", err)
		return nil, fmt.Errorf("invalid order ID: %v", err)
	}
	log.Printf("Parsed orderID: %d", orderID)

	// Get the order from the database
	order, err := r.OrderRepository.GetOrderByID(orderID)
	if err != nil {
		log.Printf("Error getting order: %v", err)
		return nil, fmt.Errorf("order not found: %v", err)
	}
	log.Printf("Found order: %+v", order)

	// Verify the Razorpay signature
	isValid := r.PaymentService.VerifySignature(input.RazorpayOrderID, input.RazorpayPaymentID, input.RazorpaySignature)
	log.Printf("Signature verification result: %v", isValid)
	if !isValid {
		return nil, fmt.Errorf("invalid payment signature")
	}

	// Check if payment already exists
	existingPayment, err := r.PaymentRepository.GetPaymentByOrderID(orderID)
	if err != nil && err != gorm.ErrRecordNotFound {
		log.Printf("Error checking existing payment: %v", err)
		return nil, fmt.Errorf("error checking existing payment: %v", err)
	}

	if err == nil && existingPayment != nil && existingPayment.ID > 0 {
		log.Printf("Updating existing payment: %+v", existingPayment)
		// Update existing payment
		existingPayment.Status = "completed"
		existingPayment.TransactionID = input.RazorpayPaymentID
		existingPayment.PaymentMethod = "razorpay"
		err = r.PaymentRepository.UpdatePayment(existingPayment)
		if err != nil {
			log.Printf("Error updating payment: %v", err)
			return nil, fmt.Errorf("failed to update payment: %v", err)
		}

		// Update order status
		order.Status = "confirmed"
		err = r.OrderRepository.UpdateOrder(order)
		if err != nil {
			log.Printf("Error updating order status: %v", err)
			return nil, fmt.Errorf("failed to update order status: %v", err)
		}

		log.Printf("Successfully updated payment: %+v", existingPayment)
		return existingPayment, nil
	}

	log.Printf("Creating new payment")
	// Create new payment record
	payment := &models.Payment{
		OrderID:       orderID,
		Amount:        order.TotalAmount,
		Status:        "completed",
		PaymentMethod: "razorpay",
		TransactionID: input.RazorpayPaymentID,
	}

	err = r.PaymentRepository.CreatePayment(payment)
	if err != nil {
		log.Printf("Error creating payment: %v", err)
		return nil, fmt.Errorf("failed to create payment: %v", err)
	}

	// Update order status to confirmed
	order.Status = "confirmed"
	err = r.OrderRepository.UpdateOrder(order)
	if err != nil {
		log.Printf("Error updating order status: %v", err)
		return nil, fmt.Errorf("failed to update order status: %v", err)
	}

	log.Printf("Successfully created payment: %+v", payment)
	return payment, nil
}
