package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"strings"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/middleware"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
	"gorm.io/gorm"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*models.Order, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	var order *models.Order
	var finalTotal float64

	// Start transaction
	err := r.DB.Transaction(func(tx *gorm.DB) error {
		// Get cart and items
		cart, err := r.CartRepository.GetCartByUserID(user.UserID)
		if err != nil {
			return fmt.Errorf("failed to get cart: %w", err)
		}

		var cartItems []models.CartItem
		err = tx.
			Where("cart_id = ?", cart.ID).
			Preload("Variant").
			Preload("Variant.Product").
			Find(&cartItems).Error

		if err != nil {
			return err
		}

		if len(cartItems) == 0 {
			return errors.New("cart is empty")
		}

		var subtotal float64
		orderItems := []models.OrderItem{}

		for _, item := range cartItems {
			price := item.Variant.Product.BasePrice + item.Variant.PriceModifier
			sub := price * float64(item.Quantity)
			subtotal += sub

			var inventory models.Inventory
			if err := tx.Where("variant_id = ?", item.VariantID).First(&inventory).Error; err != nil {
				return err
			}

			if inventory.StockQuantity < item.Quantity {
				return fmt.Errorf("out of stock for variant %d", item.VariantID)
			}

			orderItems = append(orderItems, models.OrderItem{
				VariantID: item.VariantID,
				Quantity:  item.Quantity,
				UnitPrice: price,
				Subtotal:  sub,
			})
		}

		// Apply promo code if provided
		discount := 0.0
		if input.PromoCode != nil && *input.PromoCode != "" {
			// Re-validate promo
			validation, err := r.PromoCodeService.ValidatePromoCode(*input.PromoCode, subtotal)
			if err != nil {
				return err
			}

			if !validation.IsValid {
				return errors.New(validation.Message)
			}

			discount = validation.DiscountAmount

			// Atomically increment usage
			promo, err := r.PromoCodeRepo.FindByCode(*input.PromoCode)
			if err != nil {
				return err
			}

			if promo.UsageLimit != nil {
				affected, err := r.PromoCodeRepo.IncrementUsageWithLimit(tx, *input.PromoCode, *promo.UsageLimit)
				if err != nil {
					return err
				}
				if affected == 0 {
					return errors.New("promo code usage limit reached")
				}
			} else {
				if err := tx.Model(&models.PromoCode{}).
					Where("code = ?", strings.ToUpper(*input.PromoCode)).
					Update("usage_count", gorm.Expr("usage_count + ?", 1)).Error; err != nil {
					return err
				}
			}
		}

		finalTotal = subtotal - discount

		// Create order
		order = &models.Order{
			UserID:          user.UserID,
			TotalAmount:     finalTotal,
			Discount:        discount,
			PromoCode:       input.PromoCode,
			Status:          "pending",
			ShippingAddress: input.ShippingAddress,
			OrderItems:      orderItems,
		}

		if err := tx.Create(order).Error; err != nil {
			return err
		}

		// Reduce inventory
		for _, item := range cartItems {
			if err := tx.Model(&models.Inventory{}).
				Where("variant_id = ?", item.VariantID).
				Update("stock_quantity", gorm.Expr("stock_quantity - ?", item.Quantity)).Error; err != nil {
				return err
			}
		}

		// Clear cart
		if err := tx.Where("cart_id = ?", cart.ID).Delete(&models.CartItem{}).Error; err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return order, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string) (*models.Order, error) {
	id, _ := strconv.ParseUint(orderID, 10, 32)

	order, err := r.OrderRepository.GetOrderByID(uint(id))
	if err != nil {
		return nil, err
	}

	order.Status = status

	if err := r.OrderRepository.UpdateOrder(order); err != nil {
		return nil, err
	}

	return order, nil
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, orderID string) (*models.Order, error) {
	id, _ := strconv.ParseUint(orderID, 10, 32)

	order, err := r.OrderRepository.GetOrderByID(uint(id))
	if err != nil {
		return nil, err
	}

	if order.Status == "shipped" || order.Status == "delivered" {
		return nil, errors.New("order already shipped")
	}

	order.Status = "cancelled"

	r.OrderRepository.UpdateOrder(order)

	return order, nil
}

// ID is the resolver for the id field.
func (r *orderResolver) ID(ctx context.Context, obj *models.Order) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *models.Order) ([]*models.OrderItem, error) {
	var items []*models.OrderItem
	r.DB.Where("order_id = ?", obj.ID).Find(&items)
	return items, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *orderResolver) CreatedAt(ctx context.Context, obj *models.Order) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *orderResolver) UpdatedAt(ctx context.Context, obj *models.Order) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *orderItemResolver) ID(ctx context.Context, obj *models.OrderItem) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// OrderID is the resolver for the orderID field.
func (r *orderItemResolver) OrderID(ctx context.Context, obj *models.OrderItem) (string, error) {
	return strconv.FormatUint(uint64(obj.OrderID), 10), nil
}

// ID is the resolver for the id field.
func (r *paymentResolver) ID(ctx context.Context, obj *models.Payment) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// OrderID is the resolver for the orderID field.
func (r *paymentResolver) OrderID(ctx context.Context, obj *models.Payment) (string, error) {
	return strconv.FormatUint(uint64(obj.OrderID), 10), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *paymentResolver) CreatedAt(ctx context.Context, obj *models.Payment) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context) ([]*models.Order, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	orders, err := r.OrderRepository.GetOrdersByUserID(user.UserID)
	if err != nil {
		return nil, err
	}

	var out []*models.Order
	for i := range orders {
		out = append(out, &orders[i])
	}

	return out, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*models.Order, error) {
	orderID, _ := strconv.ParseUint(id, 10, 32)

	order, err := r.OrderRepository.GetOrderByID(uint(orderID))
	if err != nil {
		return nil, err
	}

	return order, nil
}

// AllOrders is the resolver for the allOrders field.
func (r *queryResolver) AllOrders(ctx context.Context, status *string) ([]*models.Order, error) {
	var orders []models.Order
	r.DB.Preload("OrderItems").Find(&orders)

	if status != nil {
		filtered := []models.Order{}
		for _, o := range orders {
			if o.Status == *status {
				filtered = append(filtered, o)
			}
		}
		orders = filtered
	}

	var out []*models.Order
	for i := range orders {
		out = append(out, &orders[i])
	}

	return out, nil
}

// Order returns generated.OrderResolver implementation.
func (r *Resolver) Order() generated.OrderResolver { return &orderResolver{r} }

// OrderItem returns generated.OrderItemResolver implementation.
func (r *Resolver) OrderItem() generated.OrderItemResolver { return &orderItemResolver{r} }

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }
