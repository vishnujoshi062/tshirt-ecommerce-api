package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/middleware"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
	"gorm.io/gorm"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*models.Order, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	// ✅ Clerk-safe: user.UserID is STRING
	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cart: %w", err)
	}

	var cartItems []models.CartItem
	err = r.DB.
		Where("cart_id = ?", cart.ID).
		Preload("Variant").
		Preload("Variant.Product").
		Find(&cartItems).Error

	if err != nil {
		return nil, err
	}

	if len(cartItems) == 0 {
		return nil, errors.New("cart is empty")
	}

	var total float64
	orderItems := []models.OrderItem{}

	for _, item := range cartItems {
		price := item.Variant.Product.BasePrice + item.Variant.PriceModifier
		sub := price * float64(item.Quantity)
		total += sub

		var inventory models.Inventory
		if err := r.DB.Where("variant_id = ?", item.VariantID).First(&inventory).Error; err != nil {
			return nil, err
		}

		if inventory.StockQuantity < item.Quantity {
			return nil, fmt.Errorf("out of stock for variant %d", item.VariantID)
		}

		orderItems = append(orderItems, models.OrderItem{
			VariantID: item.VariantID,
			Quantity:  item.Quantity,
			UnitPrice: price,
			Subtotal:  sub,
		})
	}

	order := models.Order{
		UserID:          user.UserID, // ✅ STRING
		TotalAmount:     total,
		Status:          "pending",
		ShippingAddress: input.ShippingAddress,
		OrderItems:      orderItems,
	}

	if err := r.OrderRepository.CreateOrder(&order); err != nil {
		return nil, err
	}

	// Reduce inventory
	for _, item := range cartItems {
		r.DB.Model(&models.Inventory{}).
			Where("variant_id = ?", item.VariantID).
			Update("stock_quantity", gorm.Expr("stock_quantity - ?", item.Quantity))
	}

	// Clear cart
	r.CartRepository.ClearCart(cart.ID)

	return &order, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string) (*models.Order, error) {
	id, _ := strconv.ParseUint(orderID, 10, 32)

	order, err := r.OrderRepository.GetOrderByID(uint(id))
	if err != nil {
		return nil, err
	}

	order.Status = status

	if err := r.OrderRepository.UpdateOrder(order); err != nil {
		return nil, err
	}

	return order, nil
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, orderID string) (*models.Order, error) {
	id, _ := strconv.ParseUint(orderID, 10, 32)

	order, err := r.OrderRepository.GetOrderByID(uint(id))
	if err != nil {
		return nil, err
	}

	if order.Status == "shipped" || order.Status == "delivered" {
		return nil, errors.New("order already shipped")
	}

	order.Status = "cancelled"

	r.OrderRepository.UpdateOrder(order)

	return order, nil
}

// ID is the resolver for the id field.
func (r *orderResolver) ID(ctx context.Context, obj *models.Order) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *models.Order) ([]*models.OrderItem, error) {
	var items []*models.OrderItem
	r.DB.Where("order_id = ?", obj.ID).Find(&items)
	return items, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *orderResolver) CreatedAt(ctx context.Context, obj *models.Order) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *orderResolver) UpdatedAt(ctx context.Context, obj *models.Order) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *orderItemResolver) ID(ctx context.Context, obj *models.OrderItem) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// OrderID is the resolver for the orderID field.
func (r *orderItemResolver) OrderID(ctx context.Context, obj *models.OrderItem) (string, error) {
	return strconv.FormatUint(uint64(obj.OrderID), 10), nil
}

// ID is the resolver for the id field.
func (r *paymentResolver) ID(ctx context.Context, obj *models.Payment) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// OrderID is the resolver for the orderID field.
func (r *paymentResolver) OrderID(ctx context.Context, obj *models.Payment) (string, error) {
	return strconv.FormatUint(uint64(obj.OrderID), 10), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *paymentResolver) CreatedAt(ctx context.Context, obj *models.Payment) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context) ([]*models.Order, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	orders, err := r.OrderRepository.GetOrdersByUserID(user.UserID)
	if err != nil {
		return nil, err
	}

	var out []*models.Order
	for i := range orders {
		out = append(out, &orders[i])
	}

	return out, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*models.Order, error) {
	orderID, _ := strconv.ParseUint(id, 10, 32)

	order, err := r.OrderRepository.GetOrderByID(uint(orderID))
	if err != nil {
		return nil, err
	}

	return order, nil
}

// AllOrders is the resolver for the allOrders field.
func (r *queryResolver) AllOrders(ctx context.Context, status *string) ([]*models.Order, error) {
	var orders []models.Order
	r.DB.Preload("OrderItems").Find(&orders)

	if status != nil {
		filtered := []models.Order{}
		for _, o := range orders {
			if o.Status == *status {
				filtered = append(filtered, o)
			}
		}
		orders = filtered
	}

	var out []*models.Order
	for i := range orders {
		out = append(out, &orders[i])
	}

	return out, nil
}

// Order returns generated.OrderResolver implementation.
func (r *Resolver) Order() generated.OrderResolver { return &orderResolver{r} }

// OrderItem returns generated.OrderItemResolver implementation.
func (r *Resolver) OrderItem() generated.OrderItemResolver { return &orderItemResolver{r} }

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *orderResolver) UserID(ctx context.Context, obj *models.Order) (string, error) {
	return obj.UserID, nil
}
*/
