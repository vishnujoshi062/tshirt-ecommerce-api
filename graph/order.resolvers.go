package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/middleware"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input model.CreateOrderInput) (*models.Order, error) {
	// Get current user
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	// Get user's cart
	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cart: %w", err)
	}

	// Get cart items with variant and product info
	var cartItems []models.CartItem
	err = r.DB.Where("cart_id = ?", cart.ID).Preload("Variant").Preload("Variant.Product").Find(&cartItems).Error
	if err != nil {
		return nil, fmt.Errorf("failed to get cart items: %w", err)
	}

	if len(cartItems) == 0 {
		return nil, errors.New("cart is empty")
	}

	// Calculate total
	var totalAmount float64
	orderItems := make([]models.OrderItem, 0, len(cartItems))

	for _, item := range cartItems {
		unitPrice := item.Variant.Product.BasePrice + item.Variant.PriceModifier
		subtotal := unitPrice * float64(item.Quantity)
		totalAmount += subtotal

		orderItems = append(orderItems, models.OrderItem{
			VariantID: item.VariantID,
			Quantity:  item.Quantity,
			UnitPrice: unitPrice,
			Subtotal:  subtotal,
		})
	}

	// Create order
	order := models.Order{
		UserID:          user.UserID,
		TotalAmount:     totalAmount,
		Status:          "pending",
		ShippingAddress: input.ShippingAddress,
		OrderItems:      orderItems,
	}

	err = r.OrderRepository.CreateOrder(&order)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %w", err)
	}

	// Clear cart after order creation
	err = r.CartRepository.ClearCart(cart.ID)
	if err != nil {
		// Log error but don't fail the order
		fmt.Printf("Warning: failed to clear cart: %v\n", err)
	}

	return &order, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string) (*models.Order, error) {
	// Parse order ID
	id, err := strconv.ParseUint(orderID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid order ID: %w", err)
	}

	// Get order
	order, err := r.OrderRepository.GetOrderByID(uint(id))
	if err != nil {
		return nil, fmt.Errorf("order not found: %w", err)
	}

	// Update status
	order.Status = status
	err = r.OrderRepository.UpdateOrder(order)
	if err != nil {
		return nil, fmt.Errorf("failed to update order status: %w", err)
	}

	return order, nil
}

// CancelOrder is the resolver for the cancelOrder field.
func (r *mutationResolver) CancelOrder(ctx context.Context, orderID string) (*models.Order, error) {
	// Parse order ID
	id, err := strconv.ParseUint(orderID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid order ID: %w", err)
	}

	// Get order
	order, err := r.OrderRepository.GetOrderByID(uint(id))
	if err != nil {
		return nil, fmt.Errorf("order not found: %w", err)
	}

	// Check if order can be cancelled
	if order.Status == "shipped" || order.Status == "delivered" {
		return nil, errors.New("cannot cancel order that has been shipped or delivered")
	}

	// Update status to cancelled
	order.Status = "cancelled"
	err = r.OrderRepository.UpdateOrder(order)
	if err != nil {
		return nil, fmt.Errorf("failed to cancel order: %w", err)
	}

	return order, nil
}

// ID is the resolver for the id field.
func (r *orderResolver) ID(ctx context.Context, obj *models.Order) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// UserID is the resolver for the userID field.
func (r *orderResolver) UserID(ctx context.Context, obj *models.Order) (string, error) {
	return strconv.FormatUint(uint64(obj.UserID), 10), nil
}

// Items is the resolver for the items field.
func (r *orderResolver) Items(ctx context.Context, obj *models.Order) ([]*models.OrderItem, error) {
	var items []*models.OrderItem
	err := r.DB.Where("order_id = ?", obj.ID).Find(&items).Error
	if err != nil {
		return nil, err
	}
	return items, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *orderResolver) CreatedAt(ctx context.Context, obj *models.Order) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *orderResolver) UpdatedAt(ctx context.Context, obj *models.Order) (string, error) {
	return obj.UpdatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *orderItemResolver) ID(ctx context.Context, obj *models.OrderItem) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// OrderID is the resolver for the orderID field.
func (r *orderItemResolver) OrderID(ctx context.Context, obj *models.OrderItem) (string, error) {
	return strconv.FormatUint(uint64(obj.OrderID), 10), nil
}

func (r *queryResolver) Orders(ctx context.Context) ([]*models.Order, error) {
	orders, err := r.OrderRepository.GetAllOrders()
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	// Convert to pointer slice
	var result []*models.Order
	for i := range orders {
		result = append(result, &orders[i])
	}

	return result, nil
}

// MyOrders is the resolver for the myOrders field.
func (r *queryResolver) MyOrders(ctx context.Context) ([]*models.Order, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	orders, err := r.OrderRepository.GetOrdersByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	// Convert to pointer slice
	var result []*models.Order
	for i := range orders {
		result = append(result, &orders[i])
	}

	return result, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id string) (*models.Order, error) {
	orderID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid order ID: %w", err)
	}

	order, err := r.OrderRepository.GetOrderByID(uint(orderID))
	if err != nil {
		return nil, fmt.Errorf("order not found: %w", err)
	}

	return order, nil
}

// AllOrders is the resolver for the allOrders field.
func (r *queryResolver) AllOrders(ctx context.Context, status *string) ([]*models.Order, error) {
	var orders []models.Order
	err := r.DB.Preload("OrderItems").Find(&orders).Error
	if err != nil {
		return nil, fmt.Errorf("failed to get orders: %w", err)
	}

	// Filter by status if provided
	if status != nil {
		var filtered []models.Order
		for _, order := range orders {
			if order.Status == *status {
				filtered = append(filtered, order)
			}
		}
		orders = filtered
	}

	// Convert to pointer slice
	var result []*models.Order
	for i := range orders {
		result = append(result, &orders[i])
	}

	return result, nil
}

// Order returns generated.OrderResolver implementation.
func (r *Resolver) Order() generated.OrderResolver { return &orderResolver{r} }

// OrderItem returns generated.OrderItemResolver implementation.
func (r *Resolver) OrderItem() generated.OrderItemResolver { return &orderItemResolver{r} }

// Payment returns generated.PaymentResolver implementation.
func (r *Resolver) Payment() generated.PaymentResolver { return &paymentResolver{r} }

type orderResolver struct{ *Resolver }
type orderItemResolver struct{ *Resolver }
type paymentResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *orderResolver) TotalAmount(ctx context.Context, obj *models.Order) (float64, error) {
	return obj.TotalAmount, nil
}
func (r *orderResolver) Status(ctx context.Context, obj *models.Order) (string, error) {
	return obj.Status, nil
}
func (r *orderResolver) ShippingAddress(ctx context.Context, obj *models.Order) (string, error) {
	return obj.ShippingAddress, nil
}
func (r *orderResolver) Payment(ctx context.Context, obj *models.Order) (*models.Payment, error) {
	var payment models.Payment
	err := r.DB.Where("order_id = ?", obj.ID).First(&payment).Error
	if err != nil {
		return nil, nil // No payment yet
	}
	return &payment, nil
}
*/

// TotalAmount is the resolver for the totalAmount field.
func (r *orderResolver) TotalAmount(ctx context.Context, obj *models.Order) (float64, error) {
	return obj.TotalAmount, nil
}

// Status is the resolver for the status field.
func (r *orderResolver) Status(ctx context.Context, obj *models.Order) (string, error) {
	return obj.Status, nil
}

// ShippingAddress is the resolver for the shippingAddress field.
func (r *orderResolver) ShippingAddress(ctx context.Context, obj *models.Order) (string, error) {
	return obj.ShippingAddress, nil
}

// Payment is the resolver for the payment field.
func (r *orderResolver) Payment(ctx context.Context, obj *models.Order) (*models.Payment, error) {
	var payment models.Payment
	err := r.DB.Where("order_id = ?", obj.ID).First(&payment).Error
	if err != nil {
		return nil, nil // No payment yet
	}
	return &payment, nil
}

// ID is the resolver for the id field.
func (r *paymentResolver) ID(ctx context.Context, obj *models.Payment) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// OrderID is the resolver for the orderID field.
func (r *paymentResolver) OrderID(ctx context.Context, obj *models.Payment) (string, error) {
	return strconv.FormatUint(uint64(obj.OrderID), 10), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *paymentResolver) CreatedAt(ctx context.Context, obj *models.Payment) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}
