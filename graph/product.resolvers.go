package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"strconv"

	"github.com/lib/pq"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
)

// ID is the resolver for the id field.
func (r *inventoryResolver) ID(ctx context.Context, obj *models.Inventory) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// VariantID is the resolver for the variantID field.
func (r *inventoryResolver) VariantID(ctx context.Context, obj *models.Inventory) (string, error) {
	return strconv.FormatUint(uint64(obj.VariantID), 10), nil
}

// AvailableQuantity is the resolver for the availableQuantity field.
func (r *inventoryResolver) AvailableQuantity(ctx context.Context, obj *models.Inventory) (int, error) {
	return obj.StockQuantity - obj.ReservedQuantity, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*models.Product, error) {
	product := &models.Product{
		Name:        input.Name,
		Description: input.Description,
		BasePrice:   input.BasePrice,
		IsActive:    true,
	}

	// Handle DesignImageURL (pointer)
	if input.DesignImageURL != nil {
		product.DesignImageURL = *input.DesignImageURL
	}

	// Handle imageURLs: if provided, use it; otherwise fall back to designImageURL
	if input.ImageURLs != nil && len(input.ImageURLs) > 0 {
		product.ImageURLs = pq.StringArray(input.ImageURLs)
	} else if input.DesignImageURL != nil && *input.DesignImageURL != "" {
		// Backward compatibility: populate imageURLs from designImageURL
		product.ImageURLs = pq.StringArray{*input.DesignImageURL}
	}

	// Handle other optional fields
	if input.Material != nil {
		product.Material = *input.Material
	}
	if input.Neckline != nil {
		product.Neckline = *input.Neckline
	}
	if input.SleeveType != nil {
		product.SleeveType = *input.SleeveType
	}
	if input.Fit != nil {
		product.Fit = *input.Fit
	}
	if input.Brand != nil {
		product.Brand = *input.Brand
	}
	if input.Category != nil {
		product.Category = *input.Category
	}
	if input.CareInstructions != nil {
		product.CareInstructions = *input.CareInstructions
	}
	if input.Weight != nil {
		product.Weight = *input.Weight
	}
	if input.Featured != nil {
		product.Featured = *input.Featured
	}

	if err := r.ProductRepository.CreateProduct(product); err != nil {
		return nil, fmt.Errorf("failed to create product: %w", err)
	}

	return product, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductInput) (*models.Product, error) {
	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID")
	}

	product, err := r.ProductRepository.GetProductByID(uint(productID))
	if err != nil {
		return nil, fmt.Errorf("product not found")
	}

	product.Name = input.Name
	product.Description = input.Description
	product.BasePrice = input.BasePrice

	// Handle DesignImageURL (pointer)
	if input.DesignImageURL != nil {
		product.DesignImageURL = *input.DesignImageURL
	}

	// Handle imageURLs: if provided, use it; otherwise fall back to designImageURL
	if input.ImageURLs != nil && len(input.ImageURLs) > 0 {
		product.ImageURLs = pq.StringArray(input.ImageURLs)
	} else if input.DesignImageURL != nil && *input.DesignImageURL != "" {
		// Backward compatibility: populate imageURLs from designImageURL
		product.ImageURLs = pq.StringArray{*input.DesignImageURL}
	}

	// Handle other optional fields
	if input.Material != nil {
		product.Material = *input.Material
	}
	if input.Neckline != nil {
		product.Neckline = *input.Neckline
	}
	if input.SleeveType != nil {
		product.SleeveType = *input.SleeveType
	}
	if input.Fit != nil {
		product.Fit = *input.Fit
	}
	if input.Brand != nil {
		product.Brand = *input.Brand
	}
	if input.Category != nil {
		product.Category = *input.Category
	}
	if input.CareInstructions != nil {
		product.CareInstructions = *input.CareInstructions
	}
	if input.Weight != nil {
		product.Weight = *input.Weight
	}
	if input.Featured != nil {
		product.Featured = *input.Featured
	}

	if err := r.ProductRepository.UpdateProduct(product); err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}

	return product, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid product ID")
	}

	if err := r.ProductRepository.DeleteProduct(uint(productID)); err != nil {
		return false, fmt.Errorf("failed to delete product: %w", err)
	}

	return true, nil
}

// CreateProductVariant is the resolver for the createProductVariant field.
func (r *mutationResolver) CreateProductVariant(ctx context.Context, input model.ProductVariantInput) (*models.ProductVariant, error) {
	productID, err := strconv.ParseUint(input.ProductID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID")
	}

	variant := models.ProductVariant{
		ProductID:     uint(productID),
		Size:          input.Size,
		Color:         input.Color,
		PriceModifier: input.PriceModifier,
		SKU:           input.Sku,
	}

	if err := r.DB.Create(&variant).Error; err != nil {
		return nil, fmt.Errorf("failed to create variant: %w", err)
	}

	inventory := models.Inventory{
		VariantID:     variant.ID,
		StockQuantity: input.StockQuantity,
	}

	if err := r.DB.Create(&inventory).Error; err != nil {
		return nil, fmt.Errorf("failed to create inventory: %w", err)
	}

	return &variant, nil
}

// UpdateInventory is the resolver for the updateInventory field.
func (r *mutationResolver) UpdateInventory(ctx context.Context, variantID string, quantity int) (*models.Inventory, error) {
	varID, err := strconv.ParseUint(variantID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid variant ID")
	}

	var inv models.Inventory
	if err := r.DB.Where("variant_id = ?", uint(varID)).First(&inv).Error; err != nil {
		return nil, fmt.Errorf("inventory not found")
	}

	inv.StockQuantity = quantity

	if err := r.DB.Save(&inv).Error; err != nil {
		return nil, fmt.Errorf("failed to update inventory: %w", err)
	}

	return &inv, nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *models.Product) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// ImageURLs is the resolver for the imageURLs field.
func (r *productResolver) ImageURLs(ctx context.Context, obj *models.Product) ([]string, error) {
	// If imageURLs is empty but designImageURL exists, populate it for backward compatibility
	if len(obj.ImageURLs) == 0 && obj.DesignImageURL != "" {
		return []string{obj.DesignImageURL}, nil
	}
	// Convert pq.StringArray to []string
	return []string(obj.ImageURLs), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *productResolver) CreatedAt(ctx context.Context, obj *models.Product) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *productVariantResolver) ID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// ProductID is the resolver for the productID field.
func (r *productVariantResolver) ProductID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return strconv.FormatUint(uint64(obj.ProductID), 10), nil
}

// Price is the resolver for the price field.
func (r *productVariantResolver) Price(ctx context.Context, obj *models.ProductVariant) (float64, error) {
	var product models.Product
	if err := r.DB.First(&product, obj.ProductID).Error; err != nil {
		return 0, fmt.Errorf("failed to load product")
	}

	return product.BasePrice + obj.PriceModifier, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, isActive *bool) ([]*models.Product, error) {
	products, err := r.ProductRepository.GetAllProducts()
	if err != nil {
		return nil, fmt.Errorf("failed to get products")
	}

	var out []*models.Product

	for i := range products {

		if isActive != nil && *isActive != products[i].IsActive {
			continue
		}

		if products[i].Variants == nil {
			products[i].Variants = []models.ProductVariant{}
		}

		// Backward compatibility: populate imageURLs from designImageURL if empty
		if len(products[i].ImageURLs) == 0 && products[i].DesignImageURL != "" {
			products[i].ImageURLs = pq.StringArray{products[i].DesignImageURL}
		}

		out = append(out, &products[i])
	}

	return out, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*models.Product, error) {
	pid, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID")
	}

	product, err := r.ProductRepository.GetProductByID(uint(pid))
	if err != nil {
		return nil, fmt.Errorf("product not found")
	}

	if product.Variants == nil {
		product.Variants = []models.ProductVariant{}
	}

	// Backward compatibility: populate imageURLs from designImageURL if empty
	if len(product.ImageURLs) == 0 && product.DesignImageURL != "" {
		product.ImageURLs = pq.StringArray{product.DesignImageURL}
	}

	return product, nil
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *queryResolver) ProductsByCategory(ctx context.Context, category string) ([]*models.Product, error) {
	return []*models.Product{}, nil
}

// ✅ No panic – safe return
func (r *queryResolver) ProductOptions(ctx context.Context) (*model.ProductOptions, error) {
	return &model.ProductOptions{}, nil
}

// Inventory returns generated.InventoryResolver implementation.
func (r *Resolver) Inventory() generated.InventoryResolver { return &inventoryResolver{r} }

// Product returns generated.ProductResolver implementation.
func (r *Resolver) Product() generated.ProductResolver { return &productResolver{r} }

// ProductVariant returns generated.ProductVariantResolver implementation.
func (r *Resolver) ProductVariant() generated.ProductVariantResolver {
	return &productVariantResolver{r}
}

type inventoryResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productVariantResolver struct{ *Resolver }
