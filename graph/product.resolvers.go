package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"fmt"
	"strconv"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
)

// ID is the resolver for the id field.
func (r *inventoryResolver) ID(ctx context.Context, obj *models.Inventory) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// VariantID is the resolver for the variantID field.
func (r *inventoryResolver) VariantID(ctx context.Context, obj *models.Inventory) (string, error) {
	return strconv.FormatUint(uint64(obj.VariantID), 10), nil
}

// AvailableQuantity is the resolver for the availableQuantity field.
func (r *inventoryResolver) AvailableQuantity(ctx context.Context, obj *models.Inventory) (int, error) {
	return obj.StockQuantity - obj.ReservedQuantity, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input model.ProductInput) (*models.Product, error) {
	product := &models.Product{
		Name:           input.Name,
		Description:    input.Description,
		DesignImageURL: input.DesignImageURL,
		BasePrice:      input.BasePrice,
		IsActive:       true,
	}

	err := r.ProductRepository.CreateProduct(product)
	if err != nil {
		return nil, fmt.Errorf("failed to create product: %w", err)
	}

	return product, nil
}

// UpdateProduct is the resolver for the updateProduct field.
func (r *mutationResolver) UpdateProduct(ctx context.Context, id string, input model.ProductInput) (*models.Product, error) {
	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}

	product, err := r.ProductRepository.GetProductByID(uint(productID))
	if err != nil {
		return nil, fmt.Errorf("product not found: %w", err)
	}

	product.Name = input.Name
	product.Description = input.Description
	product.DesignImageURL = input.DesignImageURL
	product.BasePrice = input.BasePrice

	err = r.ProductRepository.UpdateProduct(product)
	if err != nil {
		return nil, fmt.Errorf("failed to update product: %w", err)
	}

	return product, nil
}

// DeleteProduct is the resolver for the deleteProduct field.
func (r *mutationResolver) DeleteProduct(ctx context.Context, id string) (bool, error) {
	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return false, fmt.Errorf("invalid product ID: %w", err)
	}

	err = r.ProductRepository.DeleteProduct(uint(productID))
	if err != nil {
		return false, fmt.Errorf("failed to delete product: %w", err)
	}

	return true, nil
}

// CreateProductVariant is the resolver for the createProductVariant field.
func (r *mutationResolver) CreateProductVariant(ctx context.Context, input model.ProductVariantInput) (*models.ProductVariant, error) {
	productID, err := strconv.ParseUint(input.ProductID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}

	variant := models.ProductVariant{
		ProductID:     uint(productID),
		Size:          input.Size,
		Color:         input.Color,
		PriceModifier: input.PriceModifier,
		SKU:           input.Sku,
	}

	err = r.DB.Create(&variant).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create variant: %w", err)
	}

	// Create inventory for the variant
	inventory := models.Inventory{
		VariantID:     variant.ID,
		StockQuantity: input.StockQuantity,
	}

	err = r.DB.Create(&inventory).Error
	if err != nil {
		return nil, fmt.Errorf("failed to create inventory: %w", err)
	}

	return &variant, nil
}

// UpdateInventory is the resolver for the updateInventory field.
func (r *mutationResolver) UpdateInventory(ctx context.Context, variantID string, quantity int) (*models.Inventory, error) {
	varID, err := strconv.ParseUint(variantID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid variant ID: %w", err)
	}

	var inventory models.Inventory
	err = r.DB.Where("variant_id = ?", uint(varID)).First(&inventory).Error
	if err != nil {
		return nil, fmt.Errorf("inventory not found: %w", err)
	}

	inventory.StockQuantity = quantity
	err = r.DB.Save(&inventory).Error
	if err != nil {
		return nil, fmt.Errorf("failed to update inventory: %w", err)
	}

	return &inventory, nil
}

// ID is the resolver for the id field.
func (r *productResolver) ID(ctx context.Context, obj *models.Product) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *productResolver) CreatedAt(ctx context.Context, obj *models.Product) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *productVariantResolver) ID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// ProductID is the resolver for the productID field.
func (r *productVariantResolver) ProductID(ctx context.Context, obj *models.ProductVariant) (string, error) {
	return strconv.FormatUint(uint64(obj.ProductID), 10), nil
}

// Price is the resolver for the price field.
func (r *productVariantResolver) Price(ctx context.Context, obj *models.ProductVariant) (float64, error) {
	// Load product to calculate final price
	var product models.Product
	err := r.DB.First(&product, obj.ProductID).Error
	if err != nil {
		return 0, fmt.Errorf("failed to load product: %w", err)
	}

	return product.BasePrice + obj.PriceModifier, nil
}

// Products is the resolver for the products field.
func (r *queryResolver) Products(ctx context.Context, isActive *bool) ([]*models.Product, error) {
	products, err := r.ProductRepository.GetAllProducts()
	if err != nil {
		return nil, fmt.Errorf("failed to get products: %w", err)
	}

	// Convert to pointer slice
	var result []*models.Product
	for i := range products {
		// Apply isActive filter if provided
		if isActive != nil && products[i].IsActive != *isActive {
			continue
		}

		// FIX 1: Guarantee non-null returns for product variants
		// Return empty slice if variants is nil
		if products[i].Variants == nil {
			products[i].Variants = []models.ProductVariant{}
		}

		result = append(result, &products[i])
	}

	return result, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*models.Product, error) {
	productID, err := strconv.ParseUint(id, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}

	product, err := r.ProductRepository.GetProductByID(uint(productID))
	if err != nil {
		return nil, fmt.Errorf("product not found: %w", err)
	}

	return product, nil
}

// ProductsByCategory is the resolver for the productsByCategory field.
func (r *queryResolver) ProductsByCategory(ctx context.Context, category string) ([]*models.Product, error) {
	panic(fmt.Errorf("not implemented: ProductsByCategory - productsByCategory"))
}

// ProductOptions is the resolver for the productOptions field.
func (r *queryResolver) ProductOptions(ctx context.Context) (*model.ProductOptions, error) {
	panic(fmt.Errorf("not implemented: ProductOptions - productOptions"))
}

// Inventory returns generated.InventoryResolver implementation.
func (r *Resolver) Inventory() generated.InventoryResolver { return &inventoryResolver{r} }

// Product returns generated.ProductResolver implementation.
func (r *Resolver) Product() generated.ProductResolver { return &productResolver{r} }

// ProductVariant returns generated.ProductVariantResolver implementation.
func (r *Resolver) ProductVariant() generated.ProductVariantResolver {
	return &productVariantResolver{r}
}

type inventoryResolver struct{ *Resolver }
type productResolver struct{ *Resolver }
type productVariantResolver struct{ *Resolver }
