package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/middleware"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
	"gorm.io/gorm"
)

// ID is the resolver for the id field.
func (r *cartResolver) ID(ctx context.Context, obj *models.Cart) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// Items is the resolver for the items field.
func (r *cartResolver) Items(ctx context.Context, obj *models.Cart) ([]*models.CartItem, error) {
	var items []*models.CartItem
	err := r.DB.
		Where("cart_id = ?", obj.ID).
		Preload("Variant").
		Preload("Variant.Product").
		Find(&items).Error

	return items, err
}

// TotalAmount is the resolver for the totalAmount field.
func (r *cartResolver) TotalAmount(ctx context.Context, obj *models.Cart) (float64, error) {
	var items []models.CartItem

	err := r.DB.
		Preload("Variant").
		Preload("Variant.Product").
		Where("cart_id = ?", obj.ID).
		Find(&items).Error

	if err != nil {
		return 0, err
	}

	var total float64
	for _, it := range items {
		price := it.Variant.Product.BasePrice + it.Variant.PriceModifier
		total += float64(it.Quantity) * price
	}

	return total, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cartResolver) CreatedAt(ctx context.Context, obj *models.Cart) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *cartResolver) UpdatedAt(ctx context.Context, obj *models.Cart) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// ID is the resolver for the id field.
func (r *cartItemResolver) ID(ctx context.Context, obj *models.CartItem) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// ProductID is the resolver for the productId field.
func (r *cartItemResolver) ProductID(ctx context.Context, obj *models.CartItem) (string, error) {
	if obj.Variant.Product.ID != 0 {
		return strconv.FormatUint(uint64(obj.Variant.Product.ID), 10), nil
	}

	var v models.ProductVariant
	if err := r.DB.Preload("Product").First(&v, obj.VariantID).Error; err != nil {
		return "", err
	}

	return strconv.FormatUint(uint64(v.Product.ID), 10), nil
}

// VariantID is the resolver for the variantId field.
func (r *cartItemResolver) VariantID(ctx context.Context, obj *models.CartItem) (*string, error) {
	out := strconv.FormatUint(uint64(obj.VariantID), 10)
	return &out, nil
}

// UnitPrice is the resolver for the unitPrice field.
func (r *cartItemResolver) UnitPrice(ctx context.Context, obj *models.CartItem) (float64, error) {
	if obj.Variant.Product.ID != 0 {
		return obj.Variant.Product.BasePrice + obj.Variant.PriceModifier, nil
	}

	var v models.ProductVariant
	if err := r.DB.Preload("Product").First(&v, obj.VariantID).Error; err != nil {
		return 0, err
	}

	return v.Product.BasePrice + v.PriceModifier, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cartItemResolver) CreatedAt(ctx context.Context, obj *models.CartItem) (string, error) {
	return obj.AddedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *cartItemResolver) UpdatedAt(ctx context.Context, obj *models.CartItem) (string, error) {
	return obj.AddedAt.Format(time.RFC3339), nil
}

// AddToCart is the resolver for the addToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, input model.AddToCartInput) (*model.AddToCartPayload, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	if input.VariantID == nil {
		return nil, fmt.Errorf("variant ID required")
	}

	variantID, err := strconv.ParseUint(*input.VariantID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid variant ID")
	}

	// âœ… FIXED: Clerk UserID is string
	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			userIDPtr := &user.UserID
			cart = &models.Cart{UserID: userIDPtr}
			if err := r.DB.Create(cart).Error; err != nil {
				return nil, err
			}
		} else {
			return nil, err
		}
	}

	var existing models.CartItem
	err = r.DB.Where("cart_id=? AND variant_id=?", cart.ID, uint(variantID)).
		First(&existing).Error

	if err == nil {
		existing.Quantity += input.Quantity
		r.CartRepository.UpdateItem(&existing)
	} else if errors.Is(err, gorm.ErrRecordNotFound) {
		item := &models.CartItem{
			CartID:    cart.ID,
			VariantID: uint(variantID),
			Quantity:  input.Quantity,
			AddedAt:   time.Now(),
		}
		r.CartRepository.AddItem(item)
	} else {
		return nil, err
	}

	cart, _ = r.CartRepository.GetCartByUserID(user.UserID)
	return &model.AddToCartPayload{Cart: cart}, nil
}

// RemoveCartItem is the resolver for the removeCartItem field.
func (r *mutationResolver) RemoveCartItem(ctx context.Context, input model.RemoveCartItemInput) (*model.RemoveCartItemPayload, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	id, _ := strconv.ParseUint(input.CartItemID, 10, 32)

	var item models.CartItem
	if err := r.DB.Preload("Cart").First(&item, uint(id)).Error; err != nil {
		return nil, fmt.Errorf("cart item not found")
	}

	if item.Cart.UserID == nil || *item.Cart.UserID != user.UserID {
		return nil, fmt.Errorf("forbidden")
	}

	r.DB.Delete(&item)

	cart, _ := r.CartRepository.GetCartByUserID(user.UserID)
	return &model.RemoveCartItemPayload{Cart: cart}, nil
}

// ClearCart is the resolver for the clearCart field.
func (r *mutationResolver) ClearCart(ctx context.Context, input model.ClearCartInput) (*model.ClearCartPayload, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, err
	}

	r.CartRepository.ClearCart(cart.ID)

	cart, _ = r.CartRepository.GetCartByUserID(user.UserID)
	return &model.ClearCartPayload{Cart: cart}, nil
}

// AttachCartToUser is the resolver for the attachCartToUser field.
func (r *mutationResolver) AttachCartToUser(ctx context.Context, input model.AttachCartToUserInput) (*model.AttachCartToUserPayload, error) {
	panic(fmt.Errorf("not implemented: AttachCartToUser - attachCartToUser"))
}

// GetCart is the resolver for the getCart field.
func (r *queryResolver) GetCart(ctx context.Context, cartID *string, forUser *bool) (*models.Cart, error) {
	if forUser != nil && *forUser {
		user := middleware.GetUserFromContext(ctx)
		if user == nil {
			return nil, errors.New("not logged in")
		}
		return r.CartRepository.GetCartByUserID(user.UserID)
	}

	if cartID != nil {
		idVal, _ := strconv.ParseUint(*cartID, 10, 32)

		var cart models.Cart
		err := r.DB.
			Preload("CartItems").
			Preload("CartItems.Variant").
			Preload("CartItems.Variant.Product").
			First(&cart, uint(idVal)).Error

		if err != nil {
			return &models.Cart{CartItems: []models.CartItem{}}, nil
		}

		return &cart, nil
	}

	return &models.Cart{CartItems: []models.CartItem{}}, nil
}

// Cart returns generated.CartResolver implementation.
func (r *Resolver) Cart() generated.CartResolver { return &cartResolver{r} }

// CartItem returns generated.CartItemResolver implementation.
func (r *Resolver) CartItem() generated.CartItemResolver { return &cartItemResolver{r} }

type cartResolver struct{ *Resolver }
type cartItemResolver struct{ *Resolver }
