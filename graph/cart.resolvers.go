package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/middleware"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
	"gorm.io/gorm"
)

// ID is the resolver for the id field.
func (r *cartResolver) ID(ctx context.Context, obj *models.Cart) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// UserID is the resolver for the userID field.
func (r *cartResolver) UserID(ctx context.Context, obj *models.Cart) (*string, error) {
	userID := strconv.FormatUint(uint64(obj.UserID), 10)
	return &userID, nil
}

// Items is the resolver for the items field.
func (r *cartResolver) Items(ctx context.Context, obj *models.Cart) ([]*models.CartItem, error) {
	var items []*models.CartItem
	err := r.DB.Where("cart_id = ?", obj.ID).Preload("Variant").Preload("Variant.Product").Find(&items).Error
	if err != nil {
		return nil, err
	}
	return items, nil
}

// TotalAmount is the resolver for the totalAmount field.
func (r *cartResolver) TotalAmount(ctx context.Context, obj *models.Cart) (float64, error) {
	var items []models.CartItem
	err := r.DB.Preload("Variant").Preload("Variant.Product").
		Where("cart_id = ?", obj.ID).
		Find(&items).Error
	if err != nil {
		return 0, err
	}

	var total float64
	for _, it := range items {
		price := it.Variant.Product.BasePrice + it.Variant.PriceModifier
		total += float64(it.Quantity) * price
	}

	return total, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cartResolver) CreatedAt(ctx context.Context, obj *models.Cart) (string, error) {
	return obj.CreatedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *cartResolver) UpdatedAt(ctx context.Context, obj *models.Cart) (string, error) {
	return obj.UpdatedAt.Format(time.RFC3339), nil
}

// ID is the resolver for the id field.
func (r *cartItemResolver) ID(ctx context.Context, obj *models.CartItem) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// ProductID is the resolver for the productId field.
func (r *cartItemResolver) ProductID(ctx context.Context, obj *models.CartItem) (string, error) {
	// Variant may already be preloaded
	if obj.Variant.Product.ID != 0 {
		id := strconv.FormatUint(uint64(obj.Variant.Product.ID), 10)
		return id, nil
	}

	// fallback load
	var v models.ProductVariant
	if err := r.DB.Preload("Product").First(&v, obj.VariantID).Error; err != nil {
		return "", err
	}

	id := strconv.FormatUint(uint64(v.Product.ID), 10)
	return id, nil
}

// VariantID is the resolver for the variantId field.
func (r *cartItemResolver) VariantID(ctx context.Context, obj *models.CartItem) (*string, error) {
	id := strconv.FormatUint(uint64(obj.VariantID), 10)
	return &id, nil
}

// UnitPrice is the resolver for the unitPrice field.
func (r *cartItemResolver) UnitPrice(ctx context.Context, obj *models.CartItem) (float64, error) {
	if obj.Variant.ID != 0 && obj.Variant.Product.ID != 0 {
		return obj.Variant.Product.BasePrice + obj.Variant.PriceModifier, nil
	}

	var v models.ProductVariant
	if err := r.DB.Preload("Product").First(&v, obj.VariantID).Error; err != nil {
		return 0, err
	}

	return v.Product.BasePrice + v.PriceModifier, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cartItemResolver) CreatedAt(ctx context.Context, obj *models.CartItem) (string, error) {
	return obj.AddedAt.Format(time.RFC3339), nil
}

// UpdatedAt is the resolver for the updatedAt field.
func (r *cartItemResolver) UpdatedAt(ctx context.Context, obj *models.CartItem) (string, error) {
	return obj.AddedAt.Format(time.RFC3339), nil
}

// AddToCart is the resolver for the addToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, input model.AddToCartInput) (*model.AddToCartPayload, error) {
	// Get current user
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	// Parse variant ID
	if input.VariantID == nil {
		return nil, fmt.Errorf("variant ID is required")
	}
	variantID, err := strconv.ParseUint(*input.VariantID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid variant ID: %w", err)
	}

	// Get or create cart
	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			// Create new cart
			cart = &models.Cart{
				UserID: user.UserID,
			}
			err = r.DB.Create(cart).Error
			if err != nil {
				return nil, fmt.Errorf("failed to create cart: %w", err)
			}
		} else {
			return nil, fmt.Errorf("failed to get cart: %w", err)
		}
	}

	// Check if item already exists in cart
	var existingItem models.CartItem
	err = r.DB.Where("cart_id = ? AND variant_id = ?", cart.ID, uint(variantID)).First(&existingItem).Error
	if err == nil {
		// Update quantity
		existingItem.Quantity += input.Quantity
		err = r.CartRepository.UpdateItem(&existingItem)
		if err != nil {
			return nil, fmt.Errorf("failed to update cart item: %w", err)
		}
	} else if errors.Is(err, gorm.ErrRecordNotFound) {
		// Add new item
		newItem := &models.CartItem{
			CartID:    cart.ID,
			VariantID: uint(variantID),
			Quantity:  input.Quantity,
			AddedAt:   time.Now(),
		}
		err = r.CartRepository.AddItem(newItem)
		if err != nil {
			return nil, fmt.Errorf("failed to add item to cart: %w", err)
		}
	} else {
		return nil, fmt.Errorf("failed to check existing item: %w", err)
	}

	// Reload cart with items
	cart, err = r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to reload cart: %w", err)
	}

	return &model.AddToCartPayload{Cart: cart}, nil
}

// RemoveCartItem is the resolver for the removeCartItem field.
func (r *mutationResolver) RemoveCartItem(ctx context.Context, input model.RemoveCartItemInput) (*model.RemoveCartItemPayload, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized")
	}

	cartItemID, _ := strconv.ParseUint(input.CartItemID, 10, 32)

	var item models.CartItem
	err := r.DB.Preload("Cart").First(&item, uint(cartItemID)).Error
	if err != nil {
		return nil, fmt.Errorf("cart item not found")
	}

	if item.Cart.UserID != user.UserID {
		return nil, fmt.Errorf("forbidden")
	}

	if err := r.DB.Delete(&item).Error; err != nil {
		return nil, err
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, err
	}

	return &model.RemoveCartItemPayload{Cart: cart}, nil
}

// ClearCart is the resolver for the clearCart field.
func (r *mutationResolver) ClearCart(ctx context.Context, input model.ClearCartInput) (*model.ClearCartPayload, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cart: %w", err)
	}

	err = r.CartRepository.ClearCart(cart.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to clear cart: %w", err)
	}

	// return fresh (now empty) cart
	cart, err = r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to reload cart: %w", err)
	}

	return &model.ClearCartPayload{Cart: cart}, nil
}

// AttachCartToUser is the resolver for the attachCartToUser field.
func (r *mutationResolver) AttachCartToUser(ctx context.Context, input model.AttachCartToUserInput) (*model.AttachCartToUserPayload, error) {
	guestID, _ := strconv.ParseUint(input.CartID, 10, 32)
	userID, _ := strconv.ParseUint(input.UserID, 10, 32)

	var guestCart models.Cart
	if err := r.DB.Preload("CartItems").First(&guestCart, uint(guestID)).Error; err != nil {
		return nil, fmt.Errorf("guest cart not found")
	}

	destCart, err := r.CartRepository.GetCartByUserID(uint(userID))
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			destCart = &models.Cart{UserID: uint(userID)}
			r.DB.Create(destCart)
		} else {
			return nil, err
		}
	}

	for _, gi := range guestCart.CartItems {
		var existing models.CartItem
		err := r.DB.Where("cart_id=? AND variant_id=?", destCart.ID, gi.VariantID).
			First(&existing).Error

		if err == nil {
			existing.Quantity += gi.Quantity
			r.DB.Save(&existing)
		} else {
			newItem := models.CartItem{
				CartID:    destCart.ID,
				VariantID: gi.VariantID,
				Quantity:  gi.Quantity,
				AddedAt:   time.Now(),
			}
			r.DB.Create(&newItem)
		}
	}

	r.DB.Delete(&guestCart)

	finalCart, _ := r.CartRepository.GetCartByUserID(uint(userID))
	return &model.AttachCartToUserPayload{Cart: finalCart}, nil
}

// GetCart is the resolver for the getCart field.
func (r *queryResolver) GetCart(ctx context.Context, cartID *string, forUser *bool) (*models.Cart, error) {
	if forUser != nil && *forUser {
		user := middleware.GetUserFromContext(ctx)
		if user == nil {
			return nil, errors.New("not logged in")
		}
		return r.CartRepository.GetCartByUserID(user.UserID)
	}

	if cartID != nil {
		idVal, _ := strconv.ParseUint(*cartID, 10, 32)
		var cart models.Cart
		err := r.DB.Preload("CartItems").Preload("CartItems.Variant").Preload("CartItems.Variant.Product").
			First(&cart, uint(idVal)).Error

		if err != nil {
			return &models.Cart{CartItems: []models.CartItem{}}, nil
		}

		return &cart, nil
	}

	return &models.Cart{CartItems: []models.CartItem{}}, nil
}

// Cart returns generated.CartResolver implementation.
func (r *Resolver) Cart() generated.CartResolver { return &cartResolver{r} }

// CartItem returns generated.CartItemResolver implementation.
func (r *Resolver) CartItem() generated.CartItemResolver { return &cartItemResolver{r} }

type cartResolver struct{ *Resolver }
type cartItemResolver struct{ *Resolver }
