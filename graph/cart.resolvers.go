package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"fmt"
	"strconv"

	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/generated"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/graph/model"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/middleware"
	"github.com/vishnujoshi062/tshirt-ecommerce-api/internal/models"
	"gorm.io/gorm"
)

// ID is the resolver for the id field.
func (r *cartResolver) ID(ctx context.Context, obj *models.Cart) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// UserID is the resolver for the userID field.
func (r *cartResolver) UserID(ctx context.Context, obj *models.Cart) (string, error) {
	return strconv.FormatUint(uint64(obj.UserID), 10), nil
}

// Items is the resolver for the items field.
func (r *cartResolver) Items(ctx context.Context, obj *models.Cart) ([]*models.CartItem, error) {
	var items []*models.CartItem
	err := r.DB.Where("cart_id = ?", obj.ID).Preload("Variant").Preload("Variant.Product").Find(&items).Error
	if err != nil {
		return nil, err
	}
	return items, nil
}

// Subtotal is the resolver for the subtotal field.
func (r *cartResolver) Subtotal(ctx context.Context, obj *models.Cart) (float64, error) {
	var items []models.CartItem
	err := r.DB.Where("cart_id = ?", obj.ID).Preload("Variant").Preload("Variant.Product").Find(&items).Error
	if err != nil {
		return 0, err
	}

	var subtotal float64
	for _, item := range items {
		price := item.Variant.Product.BasePrice + item.Variant.PriceModifier
		subtotal += price * float64(item.Quantity)
	}

	return subtotal, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *cartResolver) CreatedAt(ctx context.Context, obj *models.Cart) (string, error) {
	return obj.CreatedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// ID is the resolver for the id field.
func (r *cartItemResolver) ID(ctx context.Context, obj *models.CartItem) (string, error) {
	return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// CartID is the resolver for the cartID field.
func (r *cartItemResolver) CartID(ctx context.Context, obj *models.CartItem) (string, error) {
	return strconv.FormatUint(uint64(obj.CartID), 10), nil
}

// ItemTotal is the resolver for the itemTotal field.
func (r *cartItemResolver) ItemTotal(ctx context.Context, obj *models.CartItem) (float64, error) {
	// Load variant and product if not loaded
	if obj.Variant.ID == 0 {
		err := r.DB.Preload("Product").First(&obj.Variant, obj.VariantID).Error
		if err != nil {
			return 0, err
		}
	}

	if obj.Variant.Product == nil || obj.Variant.Product.ID == 0 {
		var product models.Product
		err := r.DB.First(&product, obj.Variant.ProductID).Error
		if err != nil {
			return 0, err
		}
		obj.Variant.Product = &product
	}

	price := obj.Variant.Product.BasePrice + obj.Variant.PriceModifier
	return price * float64(obj.Quantity), nil
}

// AddedAt is the resolver for the addedAt field.
func (r *cartItemResolver) AddedAt(ctx context.Context, obj *models.CartItem) (string, error) {
	return obj.AddedAt.Format("2006-01-02T15:04:05Z07:00"), nil
}

// AddToCart is the resolver for the addToCart field.
func (r *mutationResolver) AddToCart(ctx context.Context, input model.AddToCartInput) (*models.Cart, error) {
	// Get current user
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	// Parse variant ID
	variantID, err := strconv.ParseUint(input.VariantID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid variant ID: %w", err)
	}

	// Get or create cart
	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			// Create new cart
			cart = &models.Cart{
				UserID: user.UserID,
			}
			err = r.DB.Create(cart).Error
			if err != nil {
				return nil, fmt.Errorf("failed to create cart: %w", err)
			}
		} else {
			return nil, fmt.Errorf("failed to get cart: %w", err)
		}
	}

	// Check if item already exists in cart
	var existingItem models.CartItem
	err = r.DB.Where("cart_id = ? AND variant_id = ?", cart.ID, uint(variantID)).First(&existingItem).Error
	if err == nil {
		// Update quantity
		existingItem.Quantity += input.Quantity
		err = r.CartRepository.UpdateItem(&existingItem)
		if err != nil {
			return nil, fmt.Errorf("failed to update cart item: %w", err)
		}
	} else if errors.Is(err, gorm.ErrRecordNotFound) {
		// Add new item
		newItem := &models.CartItem{
			CartID:    cart.ID,
			VariantID: uint(variantID),
			Quantity:  input.Quantity,
		}
		err = r.CartRepository.AddItem(newItem)
		if err != nil {
			return nil, fmt.Errorf("failed to add item to cart: %w", err)
		}
	} else {
		return nil, fmt.Errorf("failed to check existing item: %w", err)
	}

	// Reload cart with items
	cart, err = r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to reload cart: %w", err)
	}

	return cart, nil
}

// RemoveFromCart is the resolver for the removeFromCart field.
func (r *mutationResolver) RemoveFromCart(ctx context.Context, cartItemID string) (*models.Cart, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	itemID, err := strconv.ParseUint(cartItemID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid cart item ID: %w", err)
	}

	err = r.CartRepository.RemoveItem(uint(itemID))
	if err != nil {
		return nil, fmt.Errorf("failed to remove item: %w", err)
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cart: %w", err)
	}

	return cart, nil
}

// UpdateCartItemQuantity is the resolver for the updateCartItemQuantity field.
func (r *mutationResolver) UpdateCartItemQuantity(ctx context.Context, cartItemID string, quantity int) (*models.Cart, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	itemID, err := strconv.ParseUint(cartItemID, 10, 32)
	if err != nil {
		return nil, fmt.Errorf("invalid cart item ID: %w", err)
	}

	var item models.CartItem
	err = r.DB.First(&item, uint(itemID)).Error
	if err != nil {
		return nil, fmt.Errorf("cart item not found: %w", err)
	}

	item.Quantity = quantity
	err = r.CartRepository.UpdateItem(&item)
	if err != nil {
		return nil, fmt.Errorf("failed to update quantity: %w", err)
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get cart: %w", err)
	}

	return cart, nil
}

// ClearCart is the resolver for the clearCart field.
func (r *mutationResolver) ClearCart(ctx context.Context) (bool, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return false, errors.New("unauthorized: please login")
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		return false, fmt.Errorf("failed to get cart: %w", err)
	}

	err = r.CartRepository.ClearCart(cart.ID)
	if err != nil {
		return false, fmt.Errorf("failed to clear cart: %w", err)
	}

	return true, nil
}

// MyCart is the resolver for the myCart field.
func (r *queryResolver) MyCart(ctx context.Context) (*models.Cart, error) {
	user := middleware.GetUserFromContext(ctx)
	if user == nil {
		return nil, errors.New("unauthorized: please login")
	}

	cart, err := r.CartRepository.GetCartByUserID(user.UserID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			// Create new cart if doesn't exist
			cart = &models.Cart{
				UserID: user.UserID,
			}
			err = r.DB.Create(cart).Error
			if err != nil {
				return nil, fmt.Errorf("failed to create cart: %w", err)
			}
		} else {
			return nil, fmt.Errorf("failed to get cart: %w", err)
		}
	}

	return cart, nil
}

// Cart returns generated.CartResolver implementation.
func (r *Resolver) Cart() generated.CartResolver { return &cartResolver{r} }

// CartItem returns generated.CartItemResolver implementation.
func (r *Resolver) CartItem() generated.CartItemResolver { return &cartItemResolver{r} }

type cartResolver struct{ *Resolver }
type cartItemResolver struct{ *Resolver }
